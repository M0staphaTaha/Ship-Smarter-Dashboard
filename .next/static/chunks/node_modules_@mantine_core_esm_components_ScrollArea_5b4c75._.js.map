{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["../../../src/components/ScrollArea/ScrollArea.context.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.context.mjs"],"sourcesContent":["import { createSafeContext } from '../../core';\n\nexport interface ScrollAreaContextValue {\n  type: 'auto' | 'always' | 'scroll' | 'hover' | 'never';\n  scrollHideDelay: number;\n  scrollArea: HTMLDivElement | null;\n  viewport: HTMLDivElement | null;\n  onViewportChange: (viewport: HTMLDivElement | null) => void;\n  content: HTMLDivElement | null;\n  onContentChange: (content: HTMLDivElement) => void;\n  scrollbarX: HTMLDivElement | null;\n  onScrollbarXChange: (scrollbar: HTMLDivElement | null) => void;\n  scrollbarXEnabled: boolean;\n  onScrollbarXEnabledChange: (rendered: boolean) => void;\n  scrollbarY: HTMLDivElement | null;\n  onScrollbarYChange: (scrollbar: HTMLDivElement | null) => void;\n  scrollbarYEnabled: boolean;\n  onScrollbarYEnabledChange: (rendered: boolean) => void;\n  onCornerWidthChange: (width: number) => void;\n  onCornerHeightChange: (height: number) => void;\n}\n\nexport const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext<ScrollAreaContextValue>(\n  'ScrollArea.Root component was not found in tree'\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEY,MAAC,CAAC,oBAAoB,qBAAqB,GAAG,6OACxD"}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["../../../src/components/ScrollArea/use-resize-observer.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/use-resize-observer.mjs"],"sourcesContent":["import { useCallbackRef, useIsomorphicEffect } from '@mantine/hooks';\n\nexport function useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n\n  useIsomorphicEffect(() => {\n    let rAF = 0;\n    if (element) {\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n\n      resizeObserver.observe(element);\n\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n\n    return undefined;\n  }, [element, handleResize]);\n}\n",null],"names":[],"mappings":";;;;;;;;AAEO,SAAS,kBAAkB,OAAO,EAAE,QAAQ;IACjD,MAAM,eAAe,oNAAe;IACpC,mOAAoB;QAClB,IAAI,MAAM;QACV,IAAI,SAAS;YACX,MAAM,iBAAiB,IAAI,eAAe;gBACxC,qBAAqB;gBACrB,MAAM,OAAO,qBAAqB,CAAC;YAC3C;YACM,eAAe,OAAO,CAAC;YACvB,OAAO;gBACL,OAAO,oBAAoB,CAAC;gBAC5B,eAAe,SAAS,CAAC;YACjC;QACK;QACD,OAAO,KAAK;IAChB,GAAK;QAAC;QAAS;KAAa;AAC5B"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.mjs"],"sourcesContent":["import React from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { useResizeObserver } from '../use-resize-observer';\n\ninterface ScrollAreaCornerProps extends React.ComponentPropsWithoutRef<'div'> {}\n\nexport const Corner = React.forwardRef<HTMLDivElement, ScrollAreaCornerProps>((props, ref) => {\n  const { style, ...others } = props;\n  const ctx = useScrollAreaContext();\n  const [width, setWidth] = React.useState(0);\n  const [height, setHeight] = React.useState(0);\n  const hasSize = Boolean(width && height);\n\n  useResizeObserver(ctx.scrollbarX, () => {\n    const h = ctx.scrollbarX?.offsetHeight || 0;\n    ctx.onCornerHeightChange(h);\n    setHeight(h);\n  });\n\n  useResizeObserver(ctx.scrollbarY, () => {\n    const w = ctx.scrollbarY?.offsetWidth || 0;\n    ctx.onCornerWidthChange(w);\n    setWidth(w);\n  });\n\n  return hasSize ? <div {...others} ref={ref} style={{ ...style, width, height }} /> : null;\n});\n\nexport const ScrollAreaCorner = React.forwardRef<HTMLDivElement, ScrollAreaCornerProps>(\n  (props, ref) => {\n    const ctx = useScrollAreaContext();\n    const hasBothScrollbarsVisible = Boolean(ctx.scrollbarX && ctx.scrollbarY);\n    const hasCorner = ctx.type !== 'scroll' && hasBothScrollbarsVisible;\n    return hasCorner ? <Corner {...props} ref={ref} /> : null;\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;AAIY,MAAC,SAAS,yKAAM,UAAU,CAAC,CAAC,OAAO;IAC7C,MAAM,EAAE,KAAK,EAAE,GAAG,QAAQ,GAAG;IAC7B,MAAM,MAAM;IACZ,MAAM,CAAC,OAAO,SAAS,GAAG,yKAAM,QAAQ,CAAC;IACzC,MAAM,CAAC,QAAQ,UAAU,GAAG,yKAAM,QAAQ,CAAC;IAC3C,MAAM,UAAU,QAAQ,SAAS;IACjC,2NAAkB,IAAI,UAAU,EAAE;QAChC,MAAM,IAAI,IAAI,UAAU,EAAE,gBAAgB;QAC1C,IAAI,oBAAoB,CAAC;QACzB,UAAU;IACd;IACE,2NAAkB,IAAI,UAAU,EAAE;QAChC,MAAM,IAAI,IAAI,UAAU,EAAE,eAAe;QACzC,IAAI,mBAAmB,CAAC;QACxB,SAAS;IACb;IACE,OAAO,UAA0B,aAAA,GAAA,yKAAM,aAAa,CAAC,OAAO;QAAE,GAAG,MAAM;QAAE;QAAK,OAAO;YAAE,GAAG,KAAK;YAAE;YAAO;QAAQ;IAAA,KAAM;AACxH;AACY,MAAC,mBAAmB,yKAAM,UAAU,CAC9C,CAAC,OAAO;IACN,MAAM,MAAM;IACZ,MAAM,2BAA2B,QAAQ,IAAI,UAAU,IAAI,IAAI,UAAU;IACzE,MAAM,YAAY,IAAI,IAAI,KAAK,YAAY;IAC3C,OAAO,YAAS,aAAA,GAAmB,yKAAM,aAAa,CAAC,QAAQ;QAAE,GAAG,KAAK;QAAE;IAAG,KAAM;AACrF"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaRoot/ScrollAreaRoot.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaRoot/ScrollAreaRoot.mjs"],"sourcesContent":["import React, { forwardRef, useState } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { Box, BoxProps, ElementProps, Factory, useProps } from '../../../core';\nimport { ScrollAreaProvider } from '../ScrollArea.context';\n\nexport type ScrollAreaRootStylesNames =\n  | 'root'\n  | 'viewport'\n  | 'viewportInner'\n  | 'scrollbar'\n  | 'thumb'\n  | 'corner';\n\nexport type ScrollAreaRootCssVariables = {\n  root: '--sa-corner-width' | '--sa-corner-height';\n};\n\nexport interface ScrollAreaRootStylesCtx {\n  cornerWidth: number;\n  cornerHeight: number;\n}\n\nexport interface ScrollAreaRootProps extends BoxProps, ElementProps<'div'> {\n  /**\n   * Defines scrollbars behavior, `hover` by default\n   * - `hover` – scrollbars are visible when mouse is over the scroll area\n   * - `scroll` – scrollbars are visible when the scroll area is scrolled\n   * - `always` – scrollbars are always visible\n   * - `never` – scrollbars are always hidden\n   * - `auto` – similar to `overflow: auto` – scrollbars are always visible when the content is overflowing\n   * */\n  type?: 'auto' | 'always' | 'scroll' | 'hover' | 'never';\n\n  /** Axis at which scrollbars must be rendered, `'xy'` by default */\n  scrollbars?: 'x' | 'y' | 'xy' | false;\n\n  /** Scroll hide delay in ms, applicable only when type is set to `hover` or `scroll`, `1000` by default */\n  scrollHideDelay?: number;\n}\n\nexport type ScrollAreaRootFactory = Factory<{\n  props: ScrollAreaRootProps;\n  ref: HTMLDivElement;\n  stylesNames: ScrollAreaRootStylesNames;\n}>;\n\nconst defaultProps: Partial<ScrollAreaRootProps> = {\n  scrollHideDelay: 1000,\n  type: 'hover',\n};\n\nexport const ScrollAreaRoot = forwardRef<HTMLDivElement, ScrollAreaRootProps>((_props, ref) => {\n  const props = useProps('ScrollAreaRoot', defaultProps, _props);\n  const { type, scrollHideDelay, scrollbars, ...others } = props;\n\n  const [scrollArea, setScrollArea] = useState<HTMLDivElement | null>(null);\n  const [viewport, setViewport] = useState<HTMLDivElement | null>(null);\n  const [content, setContent] = useState<HTMLDivElement | null>(null);\n  const [scrollbarX, setScrollbarX] = useState<HTMLDivElement | null>(null);\n  const [scrollbarY, setScrollbarY] = useState<HTMLDivElement | null>(null);\n  const [cornerWidth, setCornerWidth] = useState(0);\n  const [cornerHeight, setCornerHeight] = useState(0);\n  const [scrollbarXEnabled, setScrollbarXEnabled] = useState(false);\n  const [scrollbarYEnabled, setScrollbarYEnabled] = useState(false);\n  const rootRef = useMergedRef(ref, (node) => setScrollArea(node));\n\n  return (\n    <ScrollAreaProvider\n      value={{\n        type: type!,\n        scrollHideDelay: scrollHideDelay!,\n        scrollArea,\n        viewport,\n        onViewportChange: setViewport,\n        content,\n        onContentChange: setContent,\n        scrollbarX,\n        onScrollbarXChange: setScrollbarX,\n        scrollbarXEnabled,\n        onScrollbarXEnabledChange: setScrollbarXEnabled,\n        scrollbarY,\n        onScrollbarYChange: setScrollbarY,\n        scrollbarYEnabled,\n        onScrollbarYEnabledChange: setScrollbarYEnabled,\n        onCornerWidthChange: setCornerWidth,\n        onCornerHeightChange: setCornerHeight,\n      }}\n    >\n      <Box\n        {...others}\n        ref={rootRef}\n        __vars={{\n          '--sa-corner-width': scrollbars !== 'xy' ? '0px' : `${cornerWidth}px`,\n          '--sa-corner-height': scrollbars !== 'xy' ? '0px' : `${cornerHeight}px`,\n        }}\n      />\n    </ScrollAreaProvider>\n  );\n});\n\nScrollAreaRoot.displayName = '@mantine/core/ScrollAreaRoot';\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAM,eAAe;IACnB,iBAAiB;IACjB,MAAM;AACR;AACY,MAAC,iBAAiB,4KAAW,CAAC,QAAQ;IAChD,MAAM,QAAQ,oNAAS,kBAAkB,cAAc;IACvD,MAAM,EAAE,IAAI,EAAE,eAAe,EAAE,UAAU,EAAE,GAAG,QAAQ,GAAG;IACzD,MAAM,CAAC,YAAY,cAAc,GAAG,0KAAS;IAC7C,MAAM,CAAC,UAAU,YAAY,GAAG,0KAAS;IACzC,MAAM,CAAC,SAAS,WAAW,GAAG,0KAAS;IACvC,MAAM,CAAC,YAAY,cAAc,GAAG,0KAAS;IAC7C,MAAM,CAAC,YAAY,cAAc,GAAG,0KAAS;IAC7C,MAAM,CAAC,aAAa,eAAe,GAAG,0KAAS;IAC/C,MAAM,CAAC,cAAc,gBAAgB,GAAG,0KAAS;IACjD,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,0KAAS;IAC3D,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,0KAAS;IAC3D,MAAM,UAAU,8MAAa,KAAK,CAAC,OAAS,cAAc;IAC1D,OAAA,aAAA,GAAuB,yKAAM,aAAa,0NAExC;QACE,OAAO;YACL;YACA;YACA;YACA;YACA,kBAAkB;YAClB;YACA,iBAAiB;YACjB;YACA,oBAAoB;YACpB;YACA,2BAA2B;YAC3B;YACA,oBAAoB;YACpB;YACA,2BAA2B;YAC3B,qBAAqB;YACrB,sBAAsB;QACvB;IACF,GACe,aAAA,GAAA,yKAAM,aAAa,4KAEjC;QACE,GAAG,MAAM;QACT,KAAK;QACL,QAAQ;YACN,qBAAqB,eAAe,OAAO,QAAQ,CAAC,EAAE,YAAY,EAAE,CAAC;YACrE,sBAAsB,eAAe,OAAO,QAAQ,CAAC,EAAE,aAAa,EAAE,CAAC;QACxE;IACF;AAGP;AACA,eAAe,WAAW,GAAG"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/get-thumb-ratio.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-ratio.mjs"],"sourcesContent":["export function getThumbRatio(viewportSize: number, contentSize: number) {\n  const ratio = viewportSize / contentSize;\n  return Number.isNaN(ratio) ? 0 : ratio;\n}\n",null],"names":[],"mappings":";;;;AACO,SAAS,cAAc,YAAY,EAAE,WAAW;IACrD,MAAM,QAAQ,eAAe;IAC7B,OAAO,OAAO,KAAK,CAAC,SAAS,IAAI;AACnC"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/get-thumb-size.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-size.mjs"],"sourcesContent":["import type { Sizes } from '../ScrollArea.types';\nimport { getThumbRatio } from './get-thumb-ratio';\n\nexport function getThumbSize(sizes: Sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;\n  return Math.max(thumbSize, 18);\n}\n",null],"names":[],"mappings":";;;;;;;AAEO,SAAS,aAAa,KAAK;IAChC,MAAM,QAAQ,4NAAc,MAAM,QAAQ,EAAE,MAAM,OAAO;IACzD,MAAM,mBAAmB,MAAM,SAAS,CAAC,YAAY,GAAG,MAAM,SAAS,CAAC,UAAU;IAClF,MAAM,YAAY,CAAC,MAAM,SAAS,CAAC,IAAI,GAAG,gBAAgB,IAAI;IAC9D,OAAO,KAAK,GAAG,CAAC,WAAW;AAC7B"}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/linear-scale.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/linear-scale.mjs"],"sourcesContent":["export function linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n",null],"names":[],"mappings":";;;;AACO,SAAS,YAAY,KAAK,EAAE,MAAM;IACvC,OAAO,CAAC;QACN,IAAI,KAAK,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,IAAI,MAAM,CAAC,EAAE,KAAK,MAAM,CAAC,EAAE,EAClD,OAAO,MAAM,CAAC,EAAE;QAClB,MAAM,QAAQ,CAAC,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,IAAK,CAAA,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE;QAC5D,OAAO,MAAM,CAAC,EAAE,GAAG,QAAS,CAAA,QAAQ,KAAK,CAAC,EAAE;IAChD;AACA"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/get-thumb-offset-from-scroll.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-offset-from-scroll.mjs"],"sourcesContent":["import type { Sizes } from '../ScrollArea.types';\nimport { getThumbSize } from './get-thumb-size';\nimport { linearScale } from './linear-scale';\n\nfunction clamp(value: number, [min, max]: [number, number]): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport function getThumbOffsetFromScroll(\n  scrollPos: number,\n  sizes: Sizes,\n  dir: 'rtl' | 'ltr' = 'ltr'\n) {\n  const thumbSizePx = getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange as [number, number]);\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n}\n",null],"names":[],"mappings":";;;;;;;;;AAGA,SAAS,MAAM,KAAK,EAAE,CAAC,KAAK,IAAI;IAC9B,OAAO,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK;AACrC;AACO,SAAS,yBAAyB,SAAS,EAAE,KAAK,EAAE,MAAM,KAAK;IACpE,MAAM,cAAc,0NAAa;IACjC,MAAM,mBAAmB,MAAM,SAAS,CAAC,YAAY,GAAG,MAAM,SAAS,CAAC,UAAU;IAClF,MAAM,YAAY,MAAM,SAAS,CAAC,IAAI,GAAG;IACzC,MAAM,eAAe,MAAM,OAAO,GAAG,MAAM,QAAQ;IACnD,MAAM,cAAc,YAAY;IAChC,MAAM,mBAAmB,QAAQ,QAAQ;QAAC;QAAG;KAAa,GAAG;QAAC,eAAe,CAAC;QAAG;KAAE;IACnF,MAAM,wBAAwB,MAAM,WAAW;IAC/C,MAAM,cAAc,oNAAY;QAAC;QAAG;KAAa,EAAE;QAAC;QAAG;KAAY;IACnE,OAAO,YAAY;AACrB"}},
    {"offset": {"line": 303, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/get-scroll-position-from-pointer.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-scroll-position-from-pointer.mjs"],"sourcesContent":["import type { Sizes } from '../ScrollArea.types';\nimport { getThumbSize } from './get-thumb-size';\nimport { linearScale } from './linear-scale';\n\nexport function getScrollPositionFromPointer(\n  pointerPos: number,\n  pointerOffset: number,\n  sizes: Sizes,\n  dir: 'ltr' | 'rtl' = 'ltr'\n) {\n  const thumbSizePx = getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange as [number, number]);\n  return interpolate(pointerPos);\n}\n",null],"names":[],"mappings":";;;;;;;;;AAGO,SAAS,6BAA6B,UAAU,EAAE,aAAa,EAAE,KAAK,EAAE,MAAM,KAAK;IACxF,MAAM,cAAc,0NAAa;IACjC,MAAM,cAAc,cAAc;IAClC,MAAM,SAAS,iBAAiB;IAChC,MAAM,qBAAqB,cAAc;IACzC,MAAM,gBAAgB,MAAM,SAAS,CAAC,YAAY,GAAG;IACrD,MAAM,gBAAgB,MAAM,SAAS,CAAC,IAAI,GAAG,MAAM,SAAS,CAAC,UAAU,GAAG;IAC1E,MAAM,eAAe,MAAM,OAAO,GAAG,MAAM,QAAQ;IACnD,MAAM,cAAc,QAAQ,QAAQ;QAAC;QAAG;KAAa,GAAG;QAAC,eAAe,CAAC;QAAG;KAAE;IAC9E,MAAM,cAAc,oNAAY;QAAC;QAAe;KAAc,EAAE;IAChE,OAAO,YAAY;AACrB"}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/is-scrolling-within-scrollbar-bounds.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/is-scrolling-within-scrollbar-bounds.mjs"],"sourcesContent":["export function isScrollingWithinScrollbarBounds(scrollPos: number, maxScrollPos: number) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n}\n",null],"names":[],"mappings":";;;;AACO,SAAS,iCAAiC,SAAS,EAAE,YAAY;IACtE,OAAO,YAAY,KAAK,YAAY;AACtC"}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/to-int.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/to-int.mjs"],"sourcesContent":["export function toInt(value?: string) {\n  return value ? parseInt(value, 10) : 0;\n}\n",null],"names":[],"mappings":";;;;AACO,SAAS,MAAM,KAAK;IACzB,OAAO,QAAQ,SAAS,OAAO,MAAM;AACvC"}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/compose-event-handlers.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/compose-event-handlers.mjs"],"sourcesContent":["export function composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return (event: E) => {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\n      ourEventHandler?.(event);\n    }\n  };\n}\n",null],"names":[],"mappings":";;;;AACO,SAAS,qBAAqB,oBAAoB,EAAE,eAAe,EAAE,EAAE,2BAA2B,IAAI,EAAE,GAAG,CAAA,CAAE;IAClH,OAAO,CAAC;QACN,uBAAuB;QACvB,IAAI,6BAA6B,SAAS,CAAC,MAAM,gBAAgB,EAAE;YACjE,kBAAkB;QACnB;IACL;AACA"}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.context.ts","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.context.mjs"],"sourcesContent":["import { createSafeContext } from '../../../core';\n\nexport interface ScrollbarContextValue {\n  hasThumb: boolean;\n  scrollbar: HTMLDivElement | null;\n  onThumbChange: (thumb: HTMLDivElement | null) => void;\n  onThumbPointerUp: () => void;\n  onThumbPointerDown: (pointerPos: { x: number; y: number }) => void;\n  onThumbPositionChange: () => void;\n}\n\nexport const [ScrollbarProvider, useScrollbarContext] = createSafeContext<ScrollbarContextValue>(\n  'ScrollAreaScrollbar was not found in tree'\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEY,MAAC,CAAC,mBAAmB,oBAAoB,GAAG,6OACtD"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.mjs"],"sourcesContent":["import React, { forwardRef, useEffect } from 'react';\nimport { useCallbackRef, useDebouncedCallback, useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { Sizes } from '../ScrollArea.types';\nimport { useResizeObserver } from '../use-resize-observer';\nimport { composeEventHandlers } from '../utils';\nimport { ScrollbarContextValue, ScrollbarProvider } from './Scrollbar.context';\n\nexport interface ScrollbarPrivateProps {\n  sizes: Sizes;\n  hasThumb: boolean;\n  onThumbChange: ScrollbarContextValue['onThumbChange'];\n  onThumbPointerUp: ScrollbarContextValue['onThumbPointerUp'];\n  onThumbPointerDown: ScrollbarContextValue['onThumbPointerDown'];\n  onThumbPositionChange: ScrollbarContextValue['onThumbPositionChange'];\n  onWheelScroll: (event: WheelEvent, maxScrollPos: number) => void;\n  onDragScroll: (pointerPos: { x: number; y: number }) => void;\n  onResize: () => void;\n}\n\ninterface ScrollbarProps\n  extends ScrollbarPrivateProps,\n    Omit<React.ComponentPropsWithoutRef<'div'>, 'onResize'> {}\n\nexport const Scrollbar = forwardRef<HTMLDivElement, ScrollbarProps>((props, forwardedRef) => {\n  const {\n    sizes,\n    hasThumb,\n    onThumbChange,\n    onThumbPointerUp,\n    onThumbPointerDown,\n    onThumbPositionChange,\n    onDragScroll,\n    onWheelScroll,\n    onResize,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext();\n  const [scrollbar, setScrollbar] = React.useState<HTMLDivElement | null>(null);\n  const composeRefs = useMergedRef(forwardedRef, (node) => setScrollbar(node));\n  const rectRef = React.useRef<ClientRect | null>(null);\n  const prevWebkitUserSelectRef = React.useRef<string>('');\n  const { viewport } = context;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);\n  const handleResize = useDebouncedCallback(onResize, 10);\n\n  const handleDragScroll = (event: React.PointerEvent<HTMLElement>) => {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({ x, y });\n    }\n  };\n\n  useEffect(() => {\n    const handleWheel = (event: WheelEvent) => {\n      const element = event.target as HTMLElement;\n      const isScrollbarWheel = scrollbar?.contains(element);\n      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);\n    };\n    document.addEventListener('wheel', handleWheel, { passive: false });\n    return () => document.removeEventListener('wheel', handleWheel, { passive: false } as any);\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n\n  useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n\n  useResizeObserver(scrollbar, handleResize);\n  useResizeObserver(context.content, handleResize);\n\n  return (\n    <ScrollbarProvider\n      value={{\n        scrollbar,\n        hasThumb,\n        onThumbChange: useCallbackRef(onThumbChange),\n        onThumbPointerUp: useCallbackRef(onThumbPointerUp),\n        onThumbPositionChange: handleThumbPositionChange,\n        onThumbPointerDown: useCallbackRef(onThumbPointerDown),\n      }}\n    >\n      <div\n        {...scrollbarProps}\n        ref={composeRefs}\n        style={{ position: 'absolute', ...scrollbarProps.style }}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const mainPointer = 0;\n          if (event.button === mainPointer) {\n            const element = event.target as HTMLElement;\n            element.setPointerCapture(event.pointerId);\n            rectRef.current = scrollbar!.getBoundingClientRect();\n            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n            document.body.style.webkitUserSelect = 'none';\n            handleDragScroll(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, handleDragScroll)}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const element = event.target as HTMLElement;\n          if (element.hasPointerCapture(event.pointerId)) {\n            element.releasePointerCapture(event.pointerId);\n          }\n          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n          rectRef.current = null;\n        })}\n      />\n    </ScrollbarProvider>\n  );\n});\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAOY,MAAC,YAAY,4KAAW,CAAC,OAAO;IAC1C,MAAM,EACJ,KAAK,EACL,QAAQ,EACR,aAAa,EACb,gBAAgB,EAChB,kBAAkB,EAClB,qBAAqB,EACrB,YAAY,EACZ,aAAa,EACb,QAAQ,EACR,GAAG,gBACJ,GAAG;IACJ,MAAM,UAAU;IAChB,MAAM,CAAC,WAAW,aAAa,GAAG,yKAAM,QAAQ,CAAC;IACjD,MAAM,cAAc,8MAAa,cAAc,CAAC,OAAS,aAAa;IACtE,MAAM,UAAU,yKAAM,MAAM,CAAC;IAC7B,MAAM,0BAA0B,yKAAM,MAAM,CAAC;IAC7C,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,MAAM,eAAe,MAAM,OAAO,GAAG,MAAM,QAAQ;IACnD,MAAM,oBAAoB,oNAAe;IACzC,MAAM,4BAA4B,oNAAe;IACjD,MAAM,eAAe,sOAAqB,UAAU;IACpD,MAAM,mBAAmB,CAAC;QACxB,IAAI,QAAQ,OAAO,EAAE;YACnB,MAAM,IAAI,MAAM,OAAO,GAAG,QAAQ,OAAO,CAAC,IAAI;YAC9C,MAAM,IAAI,MAAM,OAAO,GAAG,QAAQ,OAAO,CAAC,GAAG;YAC7C,aAAa;gBAAE;gBAAG;YAAC;QACpB;IACL;IACE,2KAAU;QACR,MAAM,cAAc,CAAC;YACnB,MAAM,UAAU,MAAM,MAAM;YAC5B,MAAM,mBAAmB,WAAW,SAAS;YAC7C,IAAI,kBACF,kBAAkB,OAAO;QACjC;QACI,SAAS,gBAAgB,CAAC,SAAS,aAAa;YAAE,SAAS;QAAK;QAChE,OAAO,IAAM,SAAS,mBAAmB,CAAC,SAAS,aAAa;gBAAE,SAAS;YAAK;IACjF,GAAE;QAAC;QAAU;QAAW;QAAc;KAAkB;IACzD,2KAAU,2BAA2B;QAAC;QAAO;KAA0B;IACvE,2NAAkB,WAAW;IAC7B,2NAAkB,QAAQ,OAAO,EAAE;IACnC,OAAA,aAAA,GAAuB,yKAAM,aAAa,+OAExC;QACE,OAAO;YACL;YACA;YACA,eAAe,oNAAe;YAC9B,kBAAkB,oNAAe;YACjC,uBAAuB;YACvB,oBAAoB,oNAAe;QACpC;IACF,GACe,aAAA,GAAA,yKAAM,aAAa,CACjC,OACA;QACE,GAAG,cAAc;QACjB,KAAK;QACL,OAAO;YAAE,UAAU;YAAY,GAAG,eAAe,KAAK;QAAE;QACxD,eAAe,0OAAqB,MAAM,aAAa,EAAE,CAAC;YACxD,MAAM,cAAc;YACpB,IAAI,MAAM,MAAM,KAAK,aAAa;gBAChC,MAAM,UAAU,MAAM,MAAM;gBAC5B,QAAQ,iBAAiB,CAAC,MAAM,SAAS;gBACzC,QAAQ,OAAO,GAAG,UAAU,qBAAqB;gBACjD,wBAAwB,OAAO,GAAG,SAAS,IAAI,CAAC,KAAK,CAAC,gBAAgB;gBACtE,SAAS,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG;gBACvC,iBAAiB;YAClB;QACX;QACQ,eAAe,0OAAqB,MAAM,aAAa,EAAE;QACzD,aAAa,0OAAqB,MAAM,WAAW,EAAE,CAAC;YACpD,MAAM,UAAU,MAAM,MAAM;YAC5B,IAAI,QAAQ,iBAAiB,CAAC,MAAM,SAAS,GAAG;gBAC9C,QAAQ,qBAAqB,CAAC,MAAM,SAAS;YAC9C;YACD,SAAS,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG,wBAAwB,OAAO;YACtE,QAAQ,OAAO,GAAG;QAC5B;IACO;AAGP"}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 537, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.mjs"],"sourcesContent":["import React, { forwardRef, useEffect, useRef, useState } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAxisProps } from '../ScrollArea.types';\nimport { getThumbSize, isScrollingWithinScrollbarBounds, toInt } from '../utils';\nimport { Scrollbar } from './Scrollbar';\n\nexport const ScrollAreaScrollbarX = forwardRef<HTMLDivElement, ScrollAreaScrollbarAxisProps>(\n  (props, forwardedRef) => {\n    const { sizes, onSizesChange, style, ...others } = props;\n    const ctx = useScrollAreaContext();\n    const [computedStyle, setComputedStyle] = useState<CSSStyleDeclaration>();\n    const ref = useRef<HTMLDivElement>(null);\n    const composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);\n\n    useEffect(() => {\n      if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n    }, [ref]);\n\n    return (\n      <Scrollbar\n        data-orientation=\"horizontal\"\n        {...others}\n        ref={composeRefs}\n        sizes={sizes}\n        style={{\n          ...style,\n          ['--sa-thumb-width' as any]: `${getThumbSize(sizes)}px`,\n        }}\n        onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.x)}\n        onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.x)}\n        onWheelScroll={(event, maxScrollPos) => {\n          if (ctx.viewport) {\n            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;\n            props.onWheelScroll(scrollPos);\n            if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n              event.preventDefault();\n            }\n          }\n        }}\n        onResize={() => {\n          if (ref.current && ctx.viewport && computedStyle) {\n            onSizesChange({\n              content: ctx.viewport.scrollWidth,\n              viewport: ctx.viewport.offsetWidth,\n              scrollbar: {\n                size: ref.current.clientWidth,\n                paddingStart: toInt(computedStyle.paddingLeft),\n                paddingEnd: toInt(computedStyle.paddingRight),\n              },\n            });\n          }\n        }}\n      />\n    );\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAMY,MAAC,uBAAuB,4KAClC,CAAC,OAAO;IACN,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK,EAAE,GAAG,QAAQ,GAAG;IACnD,MAAM,MAAM;IACZ,MAAM,CAAC,eAAe,iBAAiB,GAAG;IAC1C,MAAM,MAAM,wKAAO;IACnB,MAAM,cAAc,8MAAa,cAAc,KAAK,IAAI,kBAAkB;IAC1E,2KAAU;QACR,IAAI,IAAI,OAAO,EACb,iBAAiB,iBAAiB,IAAI,OAAO;IACrD,GAAO;QAAC;KAAI;IACR,OAAA,aAAA,GAAuB,yKAAM,aAAa,4NAExC;QACE,oBAAoB;QACpB,GAAG,MAAM;QACT,KAAK;QACL;QACA,OAAO;YACL,GAAG,KAAK;YACR,CAAC,mBAAkB,EAAG,CAAC,EAAE,0NAAa,OAAO,EAAE,CAAC;QACjD;QACD,oBAAoB,CAAC,aAAe,MAAM,kBAAkB,CAAC,WAAW,CAAC;QACzE,cAAc,CAAC,aAAe,MAAM,YAAY,CAAC,WAAW,CAAC;QAC7D,eAAe,CAAC,OAAO;YACrB,IAAI,IAAI,QAAQ,EAAE;gBAChB,MAAM,YAAY,IAAI,QAAQ,CAAC,UAAU,GAAG,MAAM,MAAM;gBACxD,MAAM,aAAa,CAAC;gBACpB,IAAI,0QAAiC,WAAW,eAAe;oBAC7D,MAAM,cAAc;gBACrB;YACF;QACF;QACD,UAAU;YACR,IAAI,IAAI,OAAO,IAAI,IAAI,QAAQ,IAAI,eAAe;gBAChD,cAAc;oBACZ,SAAS,IAAI,QAAQ,CAAC,WAAW;oBACjC,UAAU,IAAI,QAAQ,CAAC,WAAW;oBAClC,WAAW;wBACT,MAAM,IAAI,OAAO,CAAC,WAAW;wBAC7B,cAAc,wMAAM,cAAc,WAAW;wBAC7C,YAAY,wMAAM,cAAc,YAAY;oBAC7C;gBACf;YACW;QACF;IACF;AAEJ"}},
    {"offset": {"line": 604, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 609, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollbarY.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarY.mjs"],"sourcesContent":["import React, { forwardRef, useEffect, useRef } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAxisProps } from '../ScrollArea.types';\nimport { getThumbSize, isScrollingWithinScrollbarBounds, toInt } from '../utils';\nimport { Scrollbar } from './Scrollbar';\n\nexport const ScrollAreaScrollbarY = forwardRef<HTMLDivElement, ScrollAreaScrollbarAxisProps>(\n  (props, forwardedRef) => {\n    const { sizes, onSizesChange, style, ...others } = props;\n    const context = useScrollAreaContext();\n    const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n    const ref = useRef<HTMLDivElement>(null);\n    const composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);\n\n    useEffect(() => {\n      if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n    }, [ref]);\n\n    return (\n      <Scrollbar\n        {...others}\n        data-orientation=\"vertical\"\n        ref={composeRefs}\n        sizes={sizes}\n        style={{\n          ['--sa-thumb-height' as any]: `${getThumbSize(sizes)}px`,\n          ...style,\n        }}\n        onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.y)}\n        onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.y)}\n        onWheelScroll={(event, maxScrollPos) => {\n          if (context.viewport) {\n            const scrollPos = context.viewport.scrollTop + event.deltaY;\n            props.onWheelScroll(scrollPos);\n            if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n              event.preventDefault();\n            }\n          }\n        }}\n        onResize={() => {\n          if (ref.current && context.viewport && computedStyle) {\n            onSizesChange({\n              content: context.viewport.scrollHeight,\n              viewport: context.viewport.offsetHeight,\n              scrollbar: {\n                size: ref.current.clientHeight,\n                paddingStart: toInt(computedStyle.paddingTop),\n                paddingEnd: toInt(computedStyle.paddingBottom),\n              },\n            });\n          }\n        }}\n      />\n    );\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAMY,MAAC,uBAAuB,4KAClC,CAAC,OAAO;IACN,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK,EAAE,GAAG,QAAQ,GAAG;IACnD,MAAM,UAAU;IAChB,MAAM,CAAC,eAAe,iBAAiB,GAAG,yKAAM,QAAQ;IACxD,MAAM,MAAM,wKAAO;IACnB,MAAM,cAAc,8MAAa,cAAc,KAAK,QAAQ,kBAAkB;IAC9E,2KAAU;QACR,IAAI,IAAI,OAAO,EACb,iBAAiB,iBAAiB,IAAI,OAAO;IACrD,GAAO;QAAC;KAAI;IACR,OAAA,aAAA,GAAuB,yKAAM,aAAa,4NAExC;QACE,GAAG,MAAM;QACT,oBAAoB;QACpB,KAAK;QACL;QACA,OAAO;YACL,CAAC,oBAAmB,EAAG,CAAC,EAAE,0NAAa,OAAO,EAAE,CAAC;YACjD,GAAG,KAAK;QACT;QACD,oBAAoB,CAAC,aAAe,MAAM,kBAAkB,CAAC,WAAW,CAAC;QACzE,cAAc,CAAC,aAAe,MAAM,YAAY,CAAC,WAAW,CAAC;QAC7D,eAAe,CAAC,OAAO;YACrB,IAAI,QAAQ,QAAQ,EAAE;gBACpB,MAAM,YAAY,QAAQ,QAAQ,CAAC,SAAS,GAAG,MAAM,MAAM;gBAC3D,MAAM,aAAa,CAAC;gBACpB,IAAI,0QAAiC,WAAW,eAAe;oBAC7D,MAAM,cAAc;gBACrB;YACF;QACF;QACD,UAAU;YACR,IAAI,IAAI,OAAO,IAAI,QAAQ,QAAQ,IAAI,eAAe;gBACpD,cAAc;oBACZ,SAAS,QAAQ,QAAQ,CAAC,YAAY;oBACtC,UAAU,QAAQ,QAAQ,CAAC,YAAY;oBACvC,WAAW;wBACT,MAAM,IAAI,OAAO,CAAC,YAAY;wBAC9B,cAAc,wMAAM,cAAc,UAAU;wBAC5C,YAAY,wMAAM,cAAc,aAAa;oBAC9C;gBACf;YACW;QACF;IACF;AAEJ"}},
    {"offset": {"line": 676, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.mjs"],"sourcesContent":["import React, { forwardRef, useRef, useState } from 'react';\nimport { useDirection } from '../../../core';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport {\n  ScrollAreaScrollbarAxisPrivateProps,\n  ScrollAreaScrollbarAxisProps,\n  Sizes,\n} from '../ScrollArea.types';\nimport { getScrollPositionFromPointer, getThumbOffsetFromScroll, getThumbRatio } from '../utils';\nimport { ScrollAreaScrollbarX } from './ScrollbarX';\nimport { ScrollAreaScrollbarY } from './ScrollbarY';\n\nexport interface ScrollAreaScrollbarVisibleProps\n  extends Omit<ScrollAreaScrollbarAxisProps, keyof ScrollAreaScrollbarAxisPrivateProps> {\n  orientation?: 'horizontal' | 'vertical';\n}\n\nexport const ScrollAreaScrollbarVisible = forwardRef<\n  HTMLDivElement,\n  ScrollAreaScrollbarVisibleProps\n>((props, forwardedRef) => {\n  const { orientation = 'vertical', ...scrollbarProps } = props;\n  const { dir } = useDirection();\n  const context = useScrollAreaContext();\n  const thumbRef = useRef<HTMLDivElement | null>(null);\n  const pointerOffsetRef = useRef(0);\n  const [sizes, setSizes] = useState<Sizes>({\n    content: 0,\n    viewport: 0,\n    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },\n  });\n  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);\n\n  const commonProps: Omit<\n    ScrollAreaScrollbarAxisPrivateProps,\n    'onThumbPositionChange' | 'onDragScroll' | 'onWheelScroll'\n  > = {\n    ...scrollbarProps,\n    sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: (thumb) => {\n      thumbRef.current = thumb;\n    },\n    onThumbPointerUp: () => {\n      pointerOffsetRef.current = 0;\n    },\n    onThumbPointerDown: (pointerPos) => {\n      pointerOffsetRef.current = pointerPos;\n    },\n  };\n\n  const getScrollPosition = (pointerPos: number, direction?: 'ltr' | 'rtl') =>\n    getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, direction);\n\n  if (orientation === 'horizontal') {\n    return (\n      <ScrollAreaScrollbarX\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollLeft;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes, dir);\n            thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollLeft = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) {\n            context.viewport.scrollLeft = getScrollPosition(pointerPos, dir);\n          }\n        }}\n      />\n    );\n  }\n\n  if (orientation === 'vertical') {\n    return (\n      <ScrollAreaScrollbarY\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollTop;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes);\n            thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollTop = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);\n        }}\n      />\n    );\n  }\n\n  return null;\n});\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOY,MAAC,6BAA6B,4KAAW,CAAC,OAAO;IAC3D,MAAM,EAAE,cAAc,UAAU,EAAE,GAAG,gBAAgB,GAAG;IACxD,MAAM,EAAE,GAAG,EAAE,GAAG;IAChB,MAAM,UAAU;IAChB,MAAM,WAAW,wKAAO;IACxB,MAAM,mBAAmB,wKAAO;IAChC,MAAM,CAAC,OAAO,SAAS,GAAG,0KAAS;QACjC,SAAS;QACT,UAAU;QACV,WAAW;YAAE,MAAM;YAAG,cAAc;YAAG,YAAY;QAAG;IAC1D;IACE,MAAM,aAAa,4NAAc,MAAM,QAAQ,EAAE,MAAM,OAAO;IAC9D,MAAM,cAAc;QAClB,GAAG,cAAc;QACjB;QACA,eAAe;QACf,UAAU,QAAQ,aAAa,KAAK,aAAa;QACjD,eAAe,CAAC;YACd,SAAS,OAAO,GAAG;QACpB;QACD,kBAAkB;YAChB,iBAAiB,OAAO,GAAG;QAC5B;QACD,oBAAoB,CAAC;YACnB,iBAAiB,OAAO,GAAG;QAC5B;IACL;IACE,MAAM,oBAAoB,CAAC,YAAY,YAAc,kQAA6B,YAAY,iBAAiB,OAAO,EAAE,OAAO;IAC/H,IAAI,gBAAgB,cAAc;QAChC,OAAA,aAAA,GAAuB,yKAAM,aAAa,wOAExC;YACE,GAAG,WAAW;YACd,KAAK;YACL,uBAAuB;gBACrB,IAAI,QAAQ,QAAQ,IAAI,SAAS,OAAO,EAAE;oBACxC,MAAM,YAAY,QAAQ,QAAQ,CAAC,UAAU;oBAC7C,MAAM,SAAS,0PAAyB,WAAW,OAAO;oBAC1D,SAAS,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,YAAY,EAAE,OAAO,SAAS,CAAC;gBACpE;YACF;YACD,eAAe,CAAC;gBACd,IAAI,QAAQ,QAAQ,EAClB,QAAQ,QAAQ,CAAC,UAAU,GAAG;YACjC;YACD,cAAc,CAAC;gBACb,IAAI,QAAQ,QAAQ,EAAE;oBACpB,QAAQ,QAAQ,CAAC,UAAU,GAAG,kBAAkB,YAAY;gBAC7D;YACF;QACF;IAEJ;IACD,IAAI,gBAAgB,YAAY;QAC9B,OAAA,aAAA,GAAuB,yKAAM,aAAa,wOAExC;YACE,GAAG,WAAW;YACd,KAAK;YACL,uBAAuB;gBACrB,IAAI,QAAQ,QAAQ,IAAI,SAAS,OAAO,EAAE;oBACxC,MAAM,YAAY,QAAQ,QAAQ,CAAC,SAAS;oBAC5C,MAAM,SAAS,0PAAyB,WAAW;oBACnD,SAAS,OAAO,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,eAAe,EAAE,OAAO,MAAM,CAAC;gBACpE;YACF;YACD,eAAe,CAAC;gBACd,IAAI,QAAQ,QAAQ,EAClB,QAAQ,QAAQ,CAAC,SAAS,GAAG;YAChC;YACD,cAAc,CAAC;gBACb,IAAI,QAAQ,QAAQ,EAClB,QAAQ,QAAQ,CAAC,SAAS,GAAG,kBAAkB;YAClD;QACF;IAEJ;IACD,OAAO;AACT"}},
    {"offset": {"line": 793, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 798, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.mjs"],"sourcesContent":["import React, { forwardRef, useState } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { useResizeObserver } from '../use-resize-observer';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\nexport interface ScrollAreaScrollbarAutoProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarAuto = forwardRef<HTMLDivElement, ScrollAreaScrollbarAutoProps>(\n  (props, ref) => {\n    const context = useScrollAreaContext();\n    const { forceMount, ...scrollbarProps } = props;\n    const [visible, setVisible] = useState(false);\n    const isHorizontal = props.orientation === 'horizontal';\n    const handleResize = useDebouncedCallback(() => {\n      if (context.viewport) {\n        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n        const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n        setVisible(isHorizontal ? isOverflowX : isOverflowY);\n      }\n    }, 10);\n\n    useResizeObserver(context.viewport, handleResize);\n    useResizeObserver(context.content, handleResize);\n\n    if (forceMount || visible) {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={visible ? 'visible' : 'hidden'}\n          {...scrollbarProps}\n          ref={ref}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;AAQY,MAAC,0BAA0B,4KACrC,CAAC,OAAO;IACN,MAAM,UAAU;IAChB,MAAM,EAAE,UAAU,EAAE,GAAG,gBAAgB,GAAG;IAC1C,MAAM,CAAC,SAAS,WAAW,GAAG,0KAAS;IACvC,MAAM,eAAe,MAAM,WAAW,KAAK;IAC3C,MAAM,eAAe,sOAAqB;QACxC,IAAI,QAAQ,QAAQ,EAAE;YACpB,MAAM,cAAc,QAAQ,QAAQ,CAAC,WAAW,GAAG,QAAQ,QAAQ,CAAC,WAAW;YAC/E,MAAM,cAAc,QAAQ,QAAQ,CAAC,YAAY,GAAG,QAAQ,QAAQ,CAAC,YAAY;YACjF,WAAW,eAAe,cAAc;QACzC;IACF,GAAE;IACH,2NAAkB,QAAQ,QAAQ,EAAE;IACpC,2NAAkB,QAAQ,OAAO,EAAE;IACnC,IAAI,cAAc,SAAS;QACzB,OAAA,aAAA,GAAuB,yKAAM,aAAa,8PAExC;YACE,cAAc,UAAU,YAAY;YACpC,GAAG,cAAc;YACjB;QACD;IAEJ;IACD,OAAO;AACR"}},
    {"offset": {"line": 838, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 843, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarHover.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarHover.mjs"],"sourcesContent":["import React, { forwardRef, useEffect, useState } from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAuto, ScrollAreaScrollbarAutoProps } from './ScrollAreaScrollbarAuto';\n\ninterface ScrollAreaScrollbarHoverProps extends ScrollAreaScrollbarAutoProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarHover = forwardRef<HTMLDivElement, ScrollAreaScrollbarHoverProps>(\n  (props, ref) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const [visible, setVisible] = useState(false);\n\n    useEffect(() => {\n      const { scrollArea } = context;\n      let hideTimer = 0;\n      if (scrollArea) {\n        const handlePointerEnter = () => {\n          window.clearTimeout(hideTimer);\n          setVisible(true);\n        };\n        const handlePointerLeave = () => {\n          hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n        };\n        scrollArea.addEventListener('pointerenter', handlePointerEnter);\n        scrollArea.addEventListener('pointerleave', handlePointerLeave);\n        return () => {\n          window.clearTimeout(hideTimer);\n          scrollArea.removeEventListener('pointerenter', handlePointerEnter);\n          scrollArea.removeEventListener('pointerleave', handlePointerLeave);\n        };\n      }\n\n      return undefined;\n    }, [context.scrollArea, context.scrollHideDelay]);\n\n    if (forceMount || visible) {\n      return (\n        <ScrollAreaScrollbarAuto\n          data-state={visible ? 'visible' : 'hidden'}\n          {...scrollbarProps}\n          ref={ref}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;AAIY,MAAC,2BAA2B,4KACtC,CAAC,OAAO;IACN,MAAM,EAAE,UAAU,EAAE,GAAG,gBAAgB,GAAG;IAC1C,MAAM,UAAU;IAChB,MAAM,CAAC,SAAS,WAAW,GAAG,0KAAS;IACvC,2KAAU;QACR,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,IAAI,YAAY;QAChB,IAAI,YAAY;YACd,MAAM,qBAAqB;gBACzB,OAAO,YAAY,CAAC;gBACpB,WAAW;YACrB;YACQ,MAAM,qBAAqB;gBACzB,YAAY,OAAO,UAAU,CAAC,IAAM,WAAW,QAAQ,QAAQ,eAAe;YACxF;YACQ,WAAW,gBAAgB,CAAC,gBAAgB;YAC5C,WAAW,gBAAgB,CAAC,gBAAgB;YAC5C,OAAO;gBACL,OAAO,YAAY,CAAC;gBACpB,WAAW,mBAAmB,CAAC,gBAAgB;gBAC/C,WAAW,mBAAmB,CAAC,gBAAgB;YACzD;QACO;QACD,OAAO,KAAK;IACb,GAAE;QAAC,QAAQ,UAAU;QAAE,QAAQ,eAAe;KAAC;IAChD,IAAI,cAAc,SAAS;QACzB,OAAA,aAAA,GAAuB,yKAAM,aAAa,wPAExC;YACE,cAAc,UAAU,YAAY;YACpC,GAAG,cAAc;YACjB;QACD;IAEJ;IACD,OAAO;AACR"}},
    {"offset": {"line": 893, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.mjs"],"sourcesContent":["import React, { forwardRef, useEffect, useState } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { composeEventHandlers } from '../utils';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarScroll = forwardRef<HTMLDivElement, ScrollAreaScrollbarScrollProps>(\n  (props, red) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const isHorizontal = props.orientation === 'horizontal';\n    const [state, setState] = useState<'hidden' | 'idle' | 'interacting' | 'scrolling'>('hidden');\n    const debounceScrollEnd = useDebouncedCallback(() => setState('idle'), 100);\n\n    useEffect(() => {\n      if (state === 'idle') {\n        const hideTimer = window.setTimeout(() => setState('hidden'), context.scrollHideDelay);\n        return () => window.clearTimeout(hideTimer);\n      }\n\n      return undefined;\n    }, [state, context.scrollHideDelay]);\n\n    useEffect(() => {\n      const { viewport } = context;\n      const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n      if (viewport) {\n        let prevScrollPos = viewport[scrollDirection];\n        const handleScroll = () => {\n          const scrollPos = viewport[scrollDirection];\n          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n          if (hasScrollInDirectionChanged) {\n            setState('scrolling');\n            debounceScrollEnd();\n          }\n          prevScrollPos = scrollPos;\n        };\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n\n      return undefined;\n    }, [context.viewport, isHorizontal, debounceScrollEnd]);\n\n    if (forceMount || state !== 'hidden') {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={state === 'hidden' ? 'hidden' : 'visible'}\n          {...scrollbarProps}\n          ref={red}\n          onPointerEnter={composeEventHandlers(props.onPointerEnter, () => setState('interacting'))}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => setState('idle'))}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;AAQY,MAAC,4BAA4B,4KACvC,CAAC,OAAO;IACN,MAAM,EAAE,UAAU,EAAE,GAAG,gBAAgB,GAAG;IAC1C,MAAM,UAAU;IAChB,MAAM,eAAe,MAAM,WAAW,KAAK;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,0KAAS;IACnC,MAAM,oBAAoB,sOAAqB,IAAM,SAAS,SAAS;IACvE,2KAAU;QACR,IAAI,UAAU,QAAQ;YACpB,MAAM,YAAY,OAAO,UAAU,CAAC,IAAM,SAAS,WAAW,QAAQ,eAAe;YACrF,OAAO,IAAM,OAAO,YAAY,CAAC;QAClC;QACD,OAAO,KAAK;IACb,GAAE;QAAC;QAAO,QAAQ,eAAe;KAAC;IACnC,2KAAU;QACR,MAAM,EAAE,QAAQ,EAAE,GAAG;QACrB,MAAM,kBAAkB,eAAe,eAAe;QACtD,IAAI,UAAU;YACZ,IAAI,gBAAgB,QAAQ,CAAC,gBAAgB;YAC7C,MAAM,eAAe;gBACnB,MAAM,YAAY,QAAQ,CAAC,gBAAgB;gBAC3C,MAAM,8BAA8B,kBAAkB;gBACtD,IAAI,6BAA6B;oBAC/B,SAAS;oBACT;gBACD;gBACD,gBAAgB;YAC1B;YACQ,SAAS,gBAAgB,CAAC,UAAU;YACpC,OAAO,IAAM,SAAS,mBAAmB,CAAC,UAAU;QACrD;QACD,OAAO,KAAK;IACb,GAAE;QAAC,QAAQ,QAAQ;QAAE;QAAc;KAAkB;IACtD,IAAI,cAAc,UAAU,UAAU;QACpC,OAAA,aAAA,GAAuB,yKAAM,aAAa,8PAExC;YACE,cAAc,UAAU,WAAW,WAAW;YAC9C,GAAG,cAAc;YACjB,KAAK;YACL,gBAAgB,0OAAqB,MAAM,cAAc,EAAE,IAAM,SAAS;YAC1E,gBAAgB,0OAAqB,MAAM,cAAc,EAAE,IAAM,SAAS;QAC3E;IAEJ;IACD,OAAO;AACR"}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.mjs"],"sourcesContent":["import React from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { ScrollAreaScrollbarAuto } from './ScrollAreaScrollbarAuto';\nimport { ScrollAreaScrollbarHover } from './ScrollAreaScrollbarHover';\nimport { ScrollAreaScrollbarScroll } from './ScrollAreaScrollbarScroll';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbar = React.forwardRef<HTMLDivElement, ScrollAreaScrollbarProps>(\n  (props, forwardedRef) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;\n    const isHorizontal = props.orientation === 'horizontal';\n\n    React.useEffect(() => {\n      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n      return () => {\n        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n      };\n    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n\n    return context.type === 'hover' ? (\n      <ScrollAreaScrollbarHover {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'scroll' ? (\n      <ScrollAreaScrollbarScroll {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'auto' ? (\n      <ScrollAreaScrollbarAuto {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'always' ? (\n      <ScrollAreaScrollbarVisible {...scrollbarProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;AASY,MAAC,sBAAsB,yKAAM,UAAU,CACjD,CAAC,OAAO;IACN,MAAM,EAAE,UAAU,EAAE,GAAG,gBAAgB,GAAG;IAC1C,MAAM,UAAU;IAChB,MAAM,EAAE,yBAAyB,EAAE,yBAAyB,EAAE,GAAG;IACjE,MAAM,eAAe,MAAM,WAAW,KAAK;IAC3C,yKAAM,SAAS,CAAC;QACd,eAAe,0BAA0B,QAAQ,0BAA0B;QAC3E,OAAO;YACL,eAAe,0BAA0B,SAAS,0BAA0B;QACpF;IACK,GAAE;QAAC;QAAc;QAA2B;KAA0B;IACvE,OAAO,QAAQ,IAAI,KAAK,UAAO,aAAA,GAAmB,yKAAM,aAAa,0PAA2B;QAAE,GAAG,cAAc;QAAE,KAAK;QAAc;IAAU,KAAM,QAAQ,IAAI,KAAK,WAA2B,aAAA,GAAA,yKAAM,aAAa,4PAA4B;QAAE,GAAG,cAAc;QAAE,KAAK;QAAc;IAAY,KAAI,QAAQ,IAAI,KAAK,SAAM,aAAA,GAAmB,yKAAM,aAAa,wPAA0B;QAAE,GAAG,cAAc;QAAE,KAAK;QAAc;IAAU,KAAM,QAAQ,IAAI,KAAK,WAAQ,aAAA,GAAmB,yKAAM,aAAa,8PAA6B;QAAE,GAAG,cAAc;QAAE,KAAK;IAAc,KAAI;AACnkB"}},
    {"offset": {"line": 1021, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1026, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/utils/add-unlinked-scroll-listener.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/utils/add-unlinked-scroll-listener.mjs"],"sourcesContent":["export function addUnlinkedScrollListener(node: HTMLElement, handler = () => {}) {\n  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };\n  let rAF = 0;\n  (function loop() {\n    const position = { left: node.scrollLeft, top: node.scrollTop };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll) handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n  return () => window.cancelAnimationFrame(rAF);\n}\n",null],"names":[],"mappings":";;;;AACO,SAAS,0BAA0B,IAAI,EAAE,UAAU,KAC1D,CAAC;IACC,IAAI,eAAe;QAAE,MAAM,KAAK,UAAU;QAAE,KAAK,KAAK,SAAS;IAAA;IAC/D,IAAI,MAAM;IACV,CAAC,SAAS;QACR,MAAM,WAAW;YAAE,MAAM,KAAK,UAAU;YAAE,KAAK,KAAK,SAAS;QAAA;QAC7D,MAAM,qBAAqB,aAAa,IAAI,KAAK,SAAS,IAAI;QAC9D,MAAM,mBAAmB,aAAa,GAAG,KAAK,SAAS,GAAG;QAC1D,IAAI,sBAAsB,kBACxB;QACF,eAAe;QACf,MAAM,OAAO,qBAAqB,CAAC;IACvC,CAAG;IACD,OAAO,IAAM,OAAO,oBAAoB,CAAC;AAC3C"}},
    {"offset": {"line": 1051, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1056, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.mjs"],"sourcesContent":["import React, { forwardRef, useEffect, useRef } from 'react';\nimport { useDebouncedCallback, useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { useScrollbarContext } from '../ScrollAreaScrollbar/Scrollbar.context';\nimport { addUnlinkedScrollListener, composeEventHandlers } from '../utils';\n\ninterface ThumbProps extends React.ComponentPropsWithoutRef<'div'> {}\n\nexport const Thumb = forwardRef<HTMLDivElement, ThumbProps>((props, forwardedRef) => {\n  const { style, ...others } = props;\n  const scrollAreaContext = useScrollAreaContext();\n  const scrollbarContext = useScrollbarContext();\n  const { onThumbPositionChange } = scrollbarContext;\n  const composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node));\n  const removeUnlinkedScrollListenerRef = useRef<() => void>();\n  const debounceScrollEnd = useDebouncedCallback(() => {\n    if (removeUnlinkedScrollListenerRef.current) {\n      removeUnlinkedScrollListenerRef.current();\n      removeUnlinkedScrollListenerRef.current = undefined;\n    }\n  }, 100);\n\n  useEffect(() => {\n    const { viewport } = scrollAreaContext;\n    if (viewport) {\n      const handleScroll = () => {\n        debounceScrollEnd();\n        if (!removeUnlinkedScrollListenerRef.current) {\n          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);\n          removeUnlinkedScrollListenerRef.current = listener;\n          onThumbPositionChange();\n        }\n      };\n      onThumbPositionChange();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n\n    return undefined;\n  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n\n  return (\n    <div\n      data-state={scrollbarContext.hasThumb ? 'visible' : 'hidden'}\n      {...others}\n      ref={composedRef}\n      style={{\n        width: 'var(--sa-thumb-width)',\n        height: 'var(--sa-thumb-height)',\n        ...style,\n      }}\n      onPointerDownCapture={composeEventHandlers(props.onPointerDownCapture, (event) => {\n        const thumb = event.target as HTMLElement;\n        const thumbRect = thumb.getBoundingClientRect();\n        const x = event.clientX - thumbRect.left;\n        const y = event.clientY - thumbRect.top;\n        scrollbarContext.onThumbPointerDown({ x, y });\n      })}\n      onPointerUp={composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)}\n    />\n  );\n});\n\ninterface ScrollAreaThumbProps extends ThumbProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaThumb = React.forwardRef<HTMLDivElement, ScrollAreaThumbProps>(\n  (props, forwardedRef) => {\n    const { forceMount, ...thumbProps } = props;\n    const scrollbarContext = useScrollbarContext();\n\n    if (forceMount || scrollbarContext.hasThumb) {\n      return <Thumb ref={forwardedRef} {...thumbProps} />;\n    }\n\n    return null;\n  }\n);\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAMY,MAAC,QAAQ,4KAAW,CAAC,OAAO;IACtC,MAAM,EAAE,KAAK,EAAE,GAAG,QAAQ,GAAG;IAC7B,MAAM,oBAAoB;IAC1B,MAAM,mBAAmB;IACzB,MAAM,EAAE,qBAAqB,EAAE,GAAG;IAClC,MAAM,cAAc,8MAAa,cAAc,CAAC,OAAS,iBAAiB,aAAa,CAAC;IACxF,MAAM,kCAAkC;IACxC,MAAM,oBAAoB,sOAAqB;QAC7C,IAAI,gCAAgC,OAAO,EAAE;YAC3C,gCAAgC,OAAO;YACvC,gCAAgC,OAAO,GAAG,KAAK;QAChD;IACF,GAAE;IACH,2KAAU;QACR,MAAM,EAAE,QAAQ,EAAE,GAAG;QACrB,IAAI,UAAU;YACZ,MAAM,eAAe;gBACnB;gBACA,IAAI,CAAC,gCAAgC,OAAO,EAAE;oBAC5C,MAAM,WAAW,wPAA0B,UAAU;oBACrD,gCAAgC,OAAO,GAAG;oBAC1C;gBACD;YACT;YACM;YACA,SAAS,gBAAgB,CAAC,UAAU;YACpC,OAAO,IAAM,SAAS,mBAAmB,CAAC,UAAU;QACrD;QACD,OAAO,KAAK;IACb,GAAE;QAAC,kBAAkB,QAAQ;QAAE;QAAmB;KAAsB;IACzE,OAAA,aAAA,GAAuB,yKAAM,aAAa,CACxC,OACA;QACE,cAAc,iBAAiB,QAAQ,GAAG,YAAY;QACtD,GAAG,MAAM;QACT,KAAK;QACL,OAAO;YACL,OAAO;YACP,QAAQ;YACR,GAAG,KAAK;QACT;QACD,sBAAsB,0OAAqB,MAAM,oBAAoB,EAAE,CAAC;YACtE,MAAM,QAAQ,MAAM,MAAM;YAC1B,MAAM,YAAY,MAAM,qBAAqB;YAC7C,MAAM,IAAI,MAAM,OAAO,GAAG,UAAU,IAAI;YACxC,MAAM,IAAI,MAAM,OAAO,GAAG,UAAU,GAAG;YACvC,iBAAiB,kBAAkB,CAAC;gBAAE;gBAAG;YAAG;QACpD;QACM,aAAa,0OAAqB,MAAM,WAAW,EAAE,iBAAiB,gBAAgB;IACvF;AAEL;AACY,MAAC,kBAAkB,yKAAM,UAAU,CAC7C,CAAC,OAAO;IACN,MAAM,EAAE,UAAU,EAAE,GAAG,YAAY,GAAG;IACtC,MAAM,mBAAmB;IACzB,IAAI,cAAc,iBAAiB,QAAQ,EAAE;QAC3C,OAAA,aAAA,GAAuB,yKAAM,aAAa,CAAC,OAAO;YAAE,KAAK;YAAc,GAAG,UAAU;QAAA;IACrF;IACD,OAAO;AACR"}},
    {"offset": {"line": 1144, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1149, "column": 0}, "map": {"version":3,"sources":["../../../../src/components/ScrollArea/ScrollAreaViewport/ScrollAreaViewport.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaViewport/ScrollAreaViewport.mjs"],"sourcesContent":["import React, { forwardRef } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { Box, BoxProps, ElementProps } from '../../../core';\nimport { useScrollAreaContext } from '../ScrollArea.context';\n\nexport interface ScrollAreaViewportProps extends BoxProps, ElementProps<'div'> {}\n\nexport const ScrollAreaViewport = forwardRef<HTMLDivElement, ScrollAreaViewportProps>(\n  ({ children, style, ...others }, ref) => {\n    const ctx = useScrollAreaContext();\n    const rootRef = useMergedRef(ref, ctx.onViewportChange);\n\n    return (\n      <Box\n        {...others}\n        ref={rootRef}\n        style={{\n          overflowX: ctx.scrollbarXEnabled ? 'scroll' : 'hidden',\n          overflowY: ctx.scrollbarYEnabled ? 'scroll' : 'hidden',\n          ...style,\n        }}\n      >\n        <div style={{ minWidth: '100%', display: 'table' }} ref={ctx.onContentChange}>\n          {children}\n        </div>\n      </Box>\n    );\n  }\n);\n\nScrollAreaViewport.displayName = '@mantine/core/ScrollAreaViewport';\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAKY,MAAC,qBAAqB,4KAChC,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,QAAQ,EAAE;IAC/B,MAAM,MAAM;IACZ,MAAM,UAAU,8MAAa,KAAK,IAAI,gBAAgB;IACtD,OAAA,aAAA,GAAuB,yKAAM,aAAa,4KAExC;QACE,GAAG,MAAM;QACT,KAAK;QACL,OAAO;YACL,WAAW,IAAI,iBAAiB,GAAG,WAAW;YAC9C,WAAW,IAAI,iBAAiB,GAAG,WAAW;YAC9C,GAAG,KAAK;QACT;IACF,GACe,aAAA,GAAA,yKAAM,aAAa,CAAC,OAAO;QAAE,OAAO;YAAE,UAAU;YAAQ,SAAS;QAAS;QAAE,KAAK,IAAI,eAAe;IAAA,GAAI;AAE3H;AAEH,mBAAmB,WAAW,GAAG"}},
    {"offset": {"line": 1198, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1203, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.module.css.mjs"],"names":[],"mappings":""}},
    {"offset": {"line": 1217, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1222, "column": 0}, "map": {"version":3,"sources":["../../../src/components/ScrollArea/ScrollArea.tsx","/turbopack/[project]/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.mjs"],"sourcesContent":["import React, { useState } from 'react';\nimport {\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  rem,\n  StylesApiProps,\n  useProps,\n  useStyles,\n} from '../../core';\nimport { ScrollAreaCorner } from './ScrollAreaCorner/ScrollAreaCorner';\nimport { ScrollAreaRoot } from './ScrollAreaRoot/ScrollAreaRoot';\nimport { ScrollAreaScrollbar } from './ScrollAreaScrollbar/ScrollAreaScrollbar';\nimport { ScrollAreaThumb } from './ScrollAreaThumb/ScrollAreaThumb';\nimport { ScrollAreaViewport } from './ScrollAreaViewport/ScrollAreaViewport';\nimport classes from './ScrollArea.module.css';\n\nexport type ScrollAreaStylesNames = 'root' | 'viewport' | 'scrollbar' | 'thumb' | 'corner';\nexport type ScrollAreaCssVariables = {\n  root: '--scrollarea-scrollbar-size';\n};\n\nexport interface ScrollAreaProps\n  extends BoxProps,\n    StylesApiProps<ScrollAreaFactory>,\n    ElementProps<'div'> {\n  /** Scrollbar size, any valid CSS value for width/height, numbers are converted to rem, default value is 0.75rem */\n  scrollbarSize?: number | string;\n\n  /**\n   * Defines scrollbars behavior, `hover` by default\n   * - `hover` – scrollbars are visible when mouse is over the scroll area\n   * - `scroll` – scrollbars are visible when the scroll area is scrolled\n   * - `always` – scrollbars are always visible\n   * - `never` – scrollbars are always hidden\n   * - `auto` – similar to `overflow: auto` – scrollbars are always visible when the content is overflowing\n   * */\n  type?: 'auto' | 'always' | 'scroll' | 'hover' | 'never';\n\n  /** Scroll hide delay in ms, applicable only when type is set to `hover` or `scroll`, `1000` by default */\n  scrollHideDelay?: number;\n\n  /** Axis at which scrollbars must be rendered, `'xy'` by default */\n  scrollbars?: 'x' | 'y' | 'xy' | false;\n\n  /** Determines whether scrollbars should be offset with padding on given axis, `false` by default */\n  offsetScrollbars?: boolean | 'x' | 'y';\n\n  /** Assigns viewport element (scrollable container) ref */\n  viewportRef?: React.ForwardedRef<HTMLDivElement>;\n\n  /** Props passed down to the viewport element */\n  viewportProps?: React.ComponentPropsWithRef<'div'>;\n\n  /** Called with current position (`x` and `y` coordinates) when viewport is scrolled */\n  onScrollPositionChange?: (position: { x: number; y: number }) => void;\n}\n\nexport interface ScrollAreaAutosizeProps extends ScrollAreaProps {}\n\nexport type ScrollAreaFactory = Factory<{\n  props: ScrollAreaProps;\n  ref: HTMLDivElement;\n  stylesNames: ScrollAreaStylesNames;\n  vars: ScrollAreaCssVariables;\n  staticComponents: {\n    Autosize: typeof ScrollAreaAutosize;\n  };\n}>;\n\nconst defaultProps: Partial<ScrollAreaProps> = {\n  scrollHideDelay: 1000,\n  type: 'hover',\n  scrollbars: 'xy',\n};\n\nconst varsResolver = createVarsResolver<ScrollAreaFactory>((_, { scrollbarSize }) => ({\n  root: {\n    '--scrollarea-scrollbar-size': rem(scrollbarSize),\n  },\n}));\n\nexport const ScrollArea = factory<ScrollAreaFactory>((_props, ref) => {\n  const props = useProps('ScrollArea', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    scrollbarSize,\n    vars,\n    type,\n    scrollHideDelay,\n    viewportProps,\n    viewportRef,\n    onScrollPositionChange,\n    children,\n    offsetScrollbars,\n    scrollbars,\n    ...others\n  } = props;\n\n  const [scrollbarHovered, setScrollbarHovered] = useState(false);\n\n  const getStyles = useStyles<ScrollAreaFactory>({\n    name: 'ScrollArea',\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  return (\n    <ScrollAreaRoot\n      type={type === 'never' ? 'always' : type}\n      scrollHideDelay={scrollHideDelay}\n      ref={ref}\n      scrollbars={scrollbars}\n      {...getStyles('root')}\n      {...others}\n    >\n      <ScrollAreaViewport\n        {...viewportProps}\n        {...getStyles('viewport', { style: viewportProps?.style })}\n        ref={viewportRef}\n        data-offset-scrollbars={offsetScrollbars === true ? 'xy' : offsetScrollbars || undefined}\n        data-scrollbars={scrollbars || undefined}\n        onScroll={(e) => {\n          viewportProps?.onScroll?.(e);\n          onScrollPositionChange?.({ x: e.currentTarget.scrollLeft, y: e.currentTarget.scrollTop });\n        }}\n      >\n        {children}\n      </ScrollAreaViewport>\n\n      {(scrollbars === 'xy' || scrollbars === 'x') && (\n        <ScrollAreaScrollbar\n          {...getStyles('scrollbar')}\n          orientation=\"horizontal\"\n          data-hidden={type === 'never' || undefined}\n          forceMount\n          onMouseEnter={() => setScrollbarHovered(true)}\n          onMouseLeave={() => setScrollbarHovered(false)}\n        >\n          <ScrollAreaThumb {...getStyles('thumb')} />\n        </ScrollAreaScrollbar>\n      )}\n\n      {(scrollbars === 'xy' || scrollbars === 'y') && (\n        <ScrollAreaScrollbar\n          {...getStyles('scrollbar')}\n          orientation=\"vertical\"\n          data-hidden={type === 'never' || undefined}\n          forceMount\n          onMouseEnter={() => setScrollbarHovered(true)}\n          onMouseLeave={() => setScrollbarHovered(false)}\n        >\n          <ScrollAreaThumb {...getStyles('thumb')} />\n        </ScrollAreaScrollbar>\n      )}\n\n      <ScrollAreaCorner\n        {...getStyles('corner')}\n        data-hovered={scrollbarHovered || undefined}\n        data-hidden={type === 'never' || undefined}\n      />\n    </ScrollAreaRoot>\n  );\n});\n\nScrollArea.displayName = '@mantine/core/ScrollArea';\n\nexport const ScrollAreaAutosize = factory<ScrollAreaFactory>((props, ref) => {\n  const {\n    children,\n    classNames,\n    styles,\n    scrollbarSize,\n    scrollHideDelay,\n    type,\n    dir,\n    offsetScrollbars,\n    viewportRef,\n    onScrollPositionChange,\n    unstyled,\n    variant,\n    viewportProps,\n    scrollbars,\n    style,\n    vars,\n    ...others\n  } = useProps('ScrollAreaAutosize', defaultProps, props);\n\n  return (\n    <Box {...others} ref={ref} style={[{ display: 'flex', overflow: 'auto' }, style]}>\n      <Box style={{ display: 'flex', flexDirection: 'column', flex: 1 }}>\n        <ScrollArea\n          classNames={classNames}\n          styles={styles}\n          scrollHideDelay={scrollHideDelay}\n          scrollbarSize={scrollbarSize}\n          type={type}\n          dir={dir}\n          offsetScrollbars={offsetScrollbars}\n          viewportRef={viewportRef}\n          onScrollPositionChange={onScrollPositionChange}\n          unstyled={unstyled}\n          variant={variant}\n          viewportProps={viewportProps}\n          vars={vars}\n          scrollbars={scrollbars}\n        >\n          {children}\n        </ScrollArea>\n      </Box>\n    </Box>\n  );\n});\n\nScrollArea.classes = classes;\nScrollAreaAutosize.displayName = '@mantine/core/ScrollAreaAutosize';\nScrollAreaAutosize.classes = classes;\nScrollArea.Autosize = ScrollAreaAutosize;\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,MAAM,eAAe;IACnB,iBAAiB;IACjB,MAAM;IACN,YAAY;AACd;AACA,MAAM,eAAe,wPAAmB,CAAC,GAAG,EAAE,aAAa,EAAE,GAAM,CAAA;QACjE,MAAM;YACJ,+BAA+B,mMAAI;QACpC;IACH,CAAC;AACW,MAAC,aAAa,sLAAQ,CAAC,QAAQ;IACzC,MAAM,QAAQ,oNAAS,cAAc,cAAc;IACnD,MAAM,EACJ,UAAU,EACV,SAAS,EACT,KAAK,EACL,MAAM,EACN,QAAQ,EACR,aAAa,EACb,IAAI,EACJ,IAAI,EACJ,eAAe,EACf,aAAa,EACb,WAAW,EACX,sBAAsB,EACtB,QAAQ,EACR,gBAAgB,EAChB,UAAU,EACV,GAAG,QACJ,GAAG;IACJ,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,0KAAS;IACzD,MAAM,YAAY,qNAAU;QAC1B,MAAM;QACN;QACA,OAAO;QACP;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;IACE,OAAA,aAAA,GAAuB,yKAAM,aAAa,iOAExC;QACE,MAAM,SAAS,UAAU,WAAW;QACpC;QACA;QACA;QACA,GAAG,UAAU,OAAO;QACpB,GAAG,MAAM;IACV,GACe,aAAA,GAAA,yKAAM,aAAa,6OAEjC;QACE,GAAG,aAAa;QAChB,GAAG,UAAU,YAAY;YAAE,OAAO,eAAe;QAAK,EAAG;QACzD,KAAK;QACL,0BAA0B,qBAAqB,OAAO,OAAO,oBAAoB,KAAK;QACtF,mBAAmB,cAAc,KAAK;QACtC,UAAU,CAAC;YACT,eAAe,WAAW;YAC1B,yBAAyB;gBAAE,GAAG,EAAE,aAAa,CAAC,UAAU;gBAAE,GAAG,EAAE,aAAa,CAAC,SAAS;YAAA;QACvF;IACF,GACD,WAEF,CAAC,eAAe,QAAQ,eAAe,GAAG,KAAA,aAAA,GAAqB,yKAAM,aAAa,gPAEhF;QACE,GAAG,UAAU,YAAY;QACzB,aAAa;QACb,eAAe,SAAS,WAAW,KAAK;QACxC,YAAY;QACZ,cAAc,IAAM,oBAAoB;QACxC,cAAc,IAAM,oBAAoB;IACzC,GACP,aAAA,GAAsB,yKAAM,aAAa,oOAAkB;QAAE,GAAG,UAAU,QAAQ;IAAA,KAE9E,CAAC,eAAe,QAAQ,eAAe,GAAG,KAAA,aAAA,GAAqB,yKAAM,aAAa,gPAEhF;QACE,GAAG,UAAU,YAAY;QACzB,aAAa;QACb,eAAe,SAAS,WAAW,KAAK;QACxC,YAAY;QACZ,cAAc,IAAM,oBAAoB;QACxC,cAAc,IAAM,oBAAoB;IACzC,GACP,aAAA,GAAsB,yKAAM,aAAa,oOAAkB;QAAE,GAAG,UAAU,QAAQ;IAAA,KAE9D,aAAA,GAAA,yKAAM,aAAa,uOAEjC;QACE,GAAG,UAAU,SAAS;QACtB,gBAAgB,oBAAoB,KAAK;QACzC,eAAe,SAAS,WAAW,KAAK;IACzC;AAGP;AACA,WAAW,WAAW,GAAG;AACb,MAAC,qBAAqB,sLAAQ,CAAC,OAAO;IAChD,MAAM,EACJ,QAAQ,EACR,UAAU,EACV,MAAM,EACN,aAAa,EACb,eAAe,EACf,IAAI,EACJ,GAAG,EACH,gBAAgB,EAChB,WAAW,EACX,sBAAsB,EACtB,QAAQ,EACR,OAAO,EACP,aAAa,EACb,UAAU,EACV,KAAK,EACL,IAAI,EACJ,GAAG,QACJ,GAAG,oNAAS,sBAAsB,cAAc;IACjD,OAAA,aAAA,GAAuB,yKAAM,aAAa,4KAAM;QAAE,GAAG,MAAM;QAAE;QAAK,OAAO;YAAC;gBAAE,SAAS;gBAAQ,UAAU;YAAQ;YAAE;SAAM;IAAA,GAAoB,aAAA,GAAA,yKAAM,aAAa,4KAAM;QAAE,OAAO;YAAE,SAAS;YAAQ,eAAe;YAAU,MAAM;QAAC;IAAI,GAAA,aAAA,GAAkB,yKAAM,aAAa,CACvQ,YACA;QACE;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACD,GACD;AAEJ;AACA,WAAW,OAAO;AAClB,mBAAmB,WAAW,GAAG;AACjC,mBAAmB,OAAO;AAC1B,WAAW,QAAQ,GAAG"}},
    {"offset": {"line": 1383, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}